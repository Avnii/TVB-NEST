# ------------------------------------------------------------------------------
#  Copyright 2020 Forschungszentrum Jülich GmbH and Aix-Marseille Université
# "Licensed to the Apache Software Foundation (ASF) under one or more contributor
#  license agreements; and to You under the Apache License, Version 2.0. "
#
# Forschungszentrum Jülich
#  Institute: Institute for Advanced Simulation (IAS)
#    Section: Jülich Supercomputing Centre (JSC)
#   Division: High Performance Computing in Neuroscience
# Laboratory: Simulation Laboratory Neuroscience
#       Team: Multi-scale Simulation and Design
#
# ------------------------------------------------------------------------------
import os
import subprocess

# Co-Simulator's imports
import common


class Action:
    """
        - Spawns an action by means of subprocess.Popen

    Methods:
    --------
        spawn_the_action: Spawn a action (task) by using subprocess.Popen

    """
    __event_action_xml_id = None
    __popen_args = None
    __logger = None

    def __init__(self, event_action_xml_id=None, action_xml_id=None, action_popen_args_list=None, logger=None):
        self.__event_action_xml_id = event_action_xml_id
        self.__action_xml_id = action_xml_id
        self.__action_popen_args_list = action_popen_args_list
        self.__logger = logger

    def spawn_the_action(self):
        """
            Implements the main loop to manage a action based on XML configuration files

            NOTE: This method is very linked to the Spawner class since
                    in the Spawner main loop, this method is called.
        :return:

        """
        self.__logger.debug('event {}, spawning {}, {}'.format(self.__event_action_xml_id,
                                                               self.__action_xml_id,
                                                               self.__action_popen_args_list))
        # print(self.__action_popen_args_list)
        try:
            # Turning off output buffering for the child process
            os.environ['PYTHONUNBUFFERED'] = "1"

            # Spawning the action
            popen_process = subprocess.Popen(self.__action_popen_args_list,
                                             stdin=None,
                                             stdout=subprocess.PIPE,
                                             stderr=subprocess.PIPE, )

        except OSError as os_error_e:
            self.__logger.error('Action {} could not be spawned by Popen'.format(self.__action_xml_id))
            self.__logger.error('OSError: {}'.format(os_error_e.strerror))
            return common.enums.ActionReturnCodes.OS_ERROR_EXCEPTION
        except ValueError:
            self.__logger.error('Action {} reports Popen arguments error'.format(self.__action_xml_id))
            self.__logger.error('ValueError: {}'.format(self.__action_popen_args_list))
            return common.enums.ActionReturnCodes.VALUE_ERROR_EXCEPTION
        else:
            self.__logger.info('Action {} was spawned successfully'.format(self.__action_xml_id))

        # getting outputs from the spawned action until is finished
        while popen_process.poll() is None:
            stdout_line = popen_process.stdout.readline()
            if stdout_line:
                # something has been generated by the spawned action
                self.__logger.info('{}: {}'.format(self.__action_xml_id,
                                                   stdout_line.strip().decode('utf-8')))

            stderr_line = popen_process.stderr.readline()
            if stderr_line:
                # something has been generated by the spawned action
                self.__logger.error('{}: {}'.format(self.__action_xml_id,
                                                    stderr_line.strip().decode('utf-8')))

            # relinquishing the CPU time window
            os.sched_yield()

        # The spawned action has finished
        return_code = popen_process.poll()
        if not return_code == 0:
            self.__logger.error('Action {} finished returning rc={}'.format(self.__action_xml_id,
                                                                            return_code))
            return common.enums.ActionReturnCodes.NOT_OK

        self.__logger.info('Action {} done!'.format(self.__action_xml_id))
        return common.enums.ActionReturnCodes.OK

    def get_action_xml_id(self):
        return self.__action_xml_id
